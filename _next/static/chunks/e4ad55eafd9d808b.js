(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,9702,e=>{"use strict";var t=e.i(1398),r=e.i(1788),i=e.i(6817),n=e.i(870),o=e.i(5907),a=e.i(7579),s=e.i(7104);let l=r.forwardRef(({envMap:e,resolution:t=256,frames:i=1/0,children:l,makeDefault:u,...d},c)=>{let h=(0,a.useThree)(({set:e})=>e),m=(0,a.useThree)(({camera:e})=>e),f=(0,a.useThree)(({size:e})=>e),g=r.useRef(null);r.useImperativeHandle(c,()=>g.current,[]);let v=r.useRef(null),p=(0,s.useFBO)(t);r.useLayoutEffect(()=>{d.manual||g.current.updateProjectionMatrix()},[f,d]),r.useLayoutEffect(()=>{g.current.updateProjectionMatrix()}),r.useLayoutEffect(()=>{if(u)return h(()=>({camera:g.current})),()=>h(()=>({camera:m}))},[g,u,h]);let w=0,x=null,y="function"==typeof l;return(0,n.useFrame)(t=>{y&&(i===1/0||w<i)&&(v.current.visible=!1,t.gl.setRenderTarget(p),x=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,g.current),t.scene.background=x,t.gl.setRenderTarget(null),v.current.visible=!0,w++)}),r.createElement(r.Fragment,null,r.createElement("orthographicCamera",(0,o.default)({left:-(f.width/2),right:f.width/2,top:f.height/2,bottom:-(f.height/2),ref:g},d),!y&&l),r.createElement("group",{ref:v},y&&l(p.texture)))});var u=e.i(2369);function d({uniforms:e,dimensions:i}){let o=(0,r.useMemo)(()=>(0,t.jsx)("shaderMaterial",{vertexShader:"/*\r\nVertex shader that doesn't do much. It passes through the \"standard\"\r\ngeometric transforms that would be required for basic triangles to display the\r\nfragment shader effects on a 2D plane in the background.\r\n\r\nTODO:\r\nCurrently, standard projection matrix is perspective. Although it doesn't\r\nmake much of a difference visually, it should be changed to orthographic\r\n*/\r\n\r\nvoid main() {\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",fragmentShader:"uniform vec2 iResolution;\r\nuniform vec2 iMouse;\r\nuniform float iTime;\r\n/*\r\nI created this shader via ShaderToy and imported it into here by setting\r\nup appropriate conversions for ShaderToy's uniforms to the standard OpenGL ones\r\n\r\nIf you're interested, here's a link to the shader:\r\nhttps://www.shadertoy.com/view/WfGBDK\r\n*/\r\n\r\nconst float iter = 10.;\r\nconst float a = 3.;\r\n\r\nfloat plot(vec2 st, float y){\r\n    y-= st.y;\r\n    return smoothstep( 1., 0., (abs(y)/fwidth(y))/a );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float smallestRatio = 1./min(iResolution.x, iResolution.y);\r\n\r\n    vec2 uv = (2.0*fragCoord.xy -iResolution.xy)*smallestRatio;\r\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)*smallestRatio;\r\n\r\n    fragColor *= 0.;\r\n\r\n    float m = 0.;\r\n    float wset;\r\n    float dist = length(uv-mouse);\r\n    float radialDistort = 0.7/dist;\r\n    \r\n    for (float i = 0.; i < iter; i++) {\r\n        wset = 0.5*(sin((uv.x*i)+iTime)+i)/(max((i+5.)*radialDistort, i)+5.)+1.6*i/iter-0.9;\r\n        // m = min(m, abs(wset)/fwidth(wset));\r\n        // fragColor += clamp(vec4(fragCoord, 0., 0) * plot(fragCoord, wset), 0.0, 1.0);\r\n        m += clamp(plot(uv, wset), 0.0, 1.0);\r\n    }\r\n\r\n    fragColor = m * vec4(fragCoord.x/iResolution.x, (uv.y+1.)/2., 0., m) + vec4(0., 0., m*radialDistort, 0.); \r\n}\r\n\r\nvoid main()\r\n{\r\n    mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}",uniforms:e}),[]),a=(0,r.useMemo)(()=>(0,t.jsx)("planeGeometry",{args:[i.width,i.height]}),[i.width,i.height]);return(0,n.useFrame)(t=>{e.iTime.value=t.clock.elapsedTime}),(0,t.jsxs)("mesh",{scale:viewport.width,children:[a,o]})}function c(){let[e,n]=(0,r.useState)({width:document.documentElement.clientWidth,height:document.documentElement.clientHeight}),o=(0,r.useRef)(),a=(0,r.useMemo)(()=>({iResolution:{value:new u.Vector2(e.width,e.height)},iMouse:{value:new u.Vector2(0,0)},iTime:{value:0}}),[]),s=e=>{if(o.current){let t=o.current.getBoundingClientRect();a.iMouse.value.set(e.clientX*devicePixelRatio,(t.bottom-e.clientY)*devicePixelRatio)}};return(0,r.useEffect)(()=>{let t=()=>{n({width:document.documentElement.clientWidth,height:document.documentElement.clientHeight}),a.iResolution.value.set(e.width,e.height)};return window.addEventListener("resize",t),()=>window.removeEventListener("resize",t)},[]),(0,r.useEffect)(()=>(window.addEventListener("mousemove",s),()=>window.removeEventListener("mousemove",s)),[]),(0,t.jsx)("div",{ref:o,className:"background-viewport-container",style:{height:`${e.height}px`},children:(0,t.jsxs)(i.Canvas,{fallback:(0,t.jsx)("div",{children:"This website has some WebGL 3D graphics, but it seems that your device doesn't support WebGL"}),flat:!0,dpr:devicePixelRatio,frameloop:"always",children:[(0,t.jsx)(l,{makeDefault:!0,position:[0,0,.1],near:.01,far:100,left:-(e.width/2),right:e.width/2,top:e.height/2,bottom:-(e.height/2)}),(0,t.jsx)(d,{uniforms:a,dimensions:e})]})})}e.s(["BackgroundShaderViewport",()=>c,"dynamic",0,"force-static"],9702)},186,e=>{e.n(e.i(9702))}]);